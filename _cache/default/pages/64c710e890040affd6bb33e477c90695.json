{"config": {"title": "Deploying WAR files to Tomcat with Jenkins", "author": "kinow", "tags": ["jenkins", "tomcat", "docker"], "category": "blog", "time": "15:29:03", "format": null, "content_type": "html", "segments": ["content"]}, "content": {"content": [{"l": 10, "c": "**Table of Contents**\n\n* [Deploying with custom scripts](#1-deploying-with-custom-scripts)\n* [Deploying with a build tool](#2-deploying-with-a-build-tool)\n* [Deploying with a build server](#3-deploying-with-a-build-server)\n* [Final thoughts](#final-thoughts)\n\nA co-worker asked me this week about how to deploy a WAR file to Tomcat with Jenkins. In my team we are\ncurrently maintaining and deploying about 10 Java web systems, but we have no consistent way of deploying\nthe applications to Tomcat yet. In the past I used Ant, Maven, Cargo, Grunt, and Jenkins, so I\ndecided to write this short post to show a few different ways it can be achieved, &agrave; la\n[Perl's TMTOWTDI](https://en.wikipedia.org/wiki/There's_more_than_one_way_to_do_it) motto.\n\n<h2><a name=\"1-deploying-with-custom-scripts\" style=\"color: #222222;\">#1 Deploying with custom scripts</a></h2>\n\nAt first you may be tempted to write your own script to deploy to Tomcat with some Shell, Perl, Python\nor Java. But I think I would choose this option only because either I needed some feature that is not\navailable in the other options, or in order to call other tasks or debug some problem.\n\nExample:\n\n{% geshi 'bash' %}\n$ docker run -d -p 8888:8080 jeanblanchard/tomcat:8\n$ git clone https://github.com/spring-projects/spring-petclinic.git && cd spring-petclinic && mvn package\n$ curl --upload-file target/petclinic.war \"http://admin:admin@localhost:8888/manager/text/deploy?path=/spring-petclinic&update=true\"\nOK - Deployed application at context path /spring-petclinic\n{% endgeshi %}\n\n<!-- more -->\n\n### Pros\n\n* Flexible option. You can customise the deployment and even call other tasks before, after or during the\ndeployment\n* Easy to get it working, as you have few dependencies and no learning curve for learning about any tool\n\n### Cons\n\n* Susceptible to bugs ([DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself))\n* You will have to spend time maintaining your scripts if Tomcat changes (e.g. from Tomcat 6 to 7,\nthe deploy URL changed adding a '/text' token)\n* Integration with other tools, such as a build tool or build server may not be simple\n\n<h2><a name=\"2-deploying-with-a-build-tool\" style=\"color: #222222;\">#2 Deploying with a build tool</a></h2>\n\nFor this example I will use Apache Maven, but you can achieve the same with Grunt, Ant, Gradle,\nor Make. Each of these tools provide different mechanisms to call external tools, some providing\nplug-ins that can be used to deploy a WAR file to Tomcat, like Maven and the\n[Cargo plug-in](https://codehaus-cargo.github.io/cargo/Maven2+Plugin+Getting+Started.html).\n\nBut even with Maven you have a few options. For example.\n\n* You can use Cargo Maven Plug-in. This plug-in contains several options and lets you abstract how\nyou interface with Tomcat \n* You can use Maven Exec Plug-in and call some command or script that deploys your application to\nTomcat. This script can use Tomcat web services to deploy the application, or execute commands remotely\nvia SSH in the server, copying the file and stop/starting the services\n* You can even write your own plug-in, where it wouldn't be much different than option #1\n\nExample:\n\n{% geshi 'bash' %}\n$ git clone https://github.com/spring-projects/spring-petclinic.git && cd spring-petclinic\n{% endgeshi %}\n\nAdd the following to the pom.xml file, under the right XML tags, of course.\n\n{% geshi 'xml' %}\n<!-- from https://gist.github.com/mdread/5900034 -->\n<plugins>\n    <plugin>\n        <groupId>org.codehaus.cargo</groupId>\n        <artifactId>cargo-maven2-plugin</artifactId>\n        <configuration>\n            <container>\n                <containerId>tomcat7x</containerId>\n                <type>remote</type>\n            </container>\n            <configuration>\n                <type>runtime</type>\n                <properties>\n                    <cargo.hostname>${cargo.hostname}</cargo.hostname>\n                    <cargo.servlet.port>${cargo.servlet.port}</cargo.servlet.port>\n                    <cargo.tomcat.manager.url>${cargo.tomcat.manager.url}</cargo.tomcat.manager.url>\n                    <cargo.remote.username>${cargo.remote.username}</cargo.remote.username>\n                    <cargo.remote.password>${cargo.remote.password}</cargo.remote.password>\n                </properties>\n            </configuration>\n            <deployer>\n                <type>remote</type>\n            </deployer>\n            <deployables>\n                <deployable>\n                    <groupId>${project.groupId}</groupId>\n                    <artifactId>${project.artifactId}</artifactId>\n                    <type>${project.packaging}</type>\n                </deployable>\n            </deployables>\n\n        </configuration>\n    </plugin>\n</plugins>\n\n<profiles>\n    <profile>\n        <id>prod</id>\n        <properties>\n            <deploy.env>prod</deploy.env>\n            <cargo.hostname>srvprd001</cargo.hostname>\n            <cargo.servlet.port>8080</cargo.servlet.port>\n            <cargo.tomcat.manager.url>http://srvprd001:8080/manager</cargo.tomcat.manager.url>\n            <cargo.remote.username>user</cargo.remote.username>\n            <cargo.remote.password>pass</cargo.remote.password>\n        </properties>\n    </profile>\n    <profile>\n        <id>test</id>\n        <properties>\n            <deploy.env>dev</deploy.env>\n            <cargo.hostname>srvtst001</cargo.hostname>\n            <cargo.servlet.port>9090</cargo.servlet.port>\n            <cargo.tomcat.manager.url>http://srvtst001:9090/manager</cargo.tomcat.manager.url>\n            <cargo.remote.username>user</cargo.remote.username>\n            <cargo.remote.password>pass</cargo.remote.password>\n        </properties>\n    </profile>\n</profiles>\n{% endgeshi %}\n\nAnd finally start Tomcat and call the Cargo Maven plug-in.\n\n{% geshi 'bash' %}\n$ docker run -d -p 8888:8080 jeanblanchard/tomcat:8\n$ mvn package org.codehaus.cargo:cargo-maven2-plugin:deploy -Ptest -Dcargo.hostname=localhost -Dcargo.servlet.port=8888 -Dcargo.tomcat.manager.url=http://localhost:8888/manager/text -Dcargo.remote.username=admin -Dcargo.remote.password=admin\n{% endgeshi %}\n\nWhat I like about this approach is that using profiles and environments with Maven, you can have pre-defined\nvariables per profile, but also overwrite them when necessary. For example in the previous command line,\nthe host, port, user and password are overwritten to match the default values from the Docker image used.\n\n### Pros\n\n* You are using a tool that is being used by other people. So bugs are fixed much faster and by\na lot of people, with different environments and use cases\n* Normally, build tools provide some mechanism for you to parameterise your build, controlling flags\nand allowing a more flexible process\n* It is a lot easier to find examples and workarounds online\n\n### Cons\n\n* New features depend on how well maintained your build tool or plug-in is. For example, with the Maven Cargo\nPlug-in, it took some time till Java 7 was fully supported (but you can submit pull requests/patches)\n* There is a learning curve for either learning about the build tool or about its plug-ins and extension\npoints\n* Sometimes you may have to dig into the build tool or plug-in source code to debug problems in your build,\nsuch as JVM or some system library incompatibility\n\n<h2><a name=\"3-deploying-with-a-build-server\" style=\"color: #222222;\">#3 Deploying with a build server</a></h2>\n\nDeploying with a build server is not very different from approach #2. For this example I will use Jenkins,\nas this is the build server I am most familiar with, and also the one that I am using at work.\n\nExample:\n\nInstall the [Deploy Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Deploy+Plugin) in\nJenkins (it appears as \"Deploy to container Plugin\" in the plug-in selection screen), as well as the\ngit plug-in to check out the project.\n\nIn your job configuration, add a SCM step to clone the petclinic war project, and another step\nto invoke a Maven top level target execute `mvn package`. Also add a post build step to deploy with the following\nsettings.\n\n* WAR/EAR files: target/*.war\n* Context-path: spring-petclinic\n* Containers: add Tomcat 7.x\n* * Manager user name: admin\n* * Manager password: admin\n* * Tomcat URL: http://localhost:8888\n\nInstead of a screenshot, here is the config.xml file for my example job - easier to diff your job\nconfiguration.\n\n{% geshi 'xml' %}\n<?xml version='1.0' encoding='UTF-8'?>\n<project>\n  <actions/>\n  <description></description>\n  <keepDependencies>false</keepDependencies>\n  <properties/>\n  <scm class=\"hudson.plugins.git.GitSCM\" plugin=\"git@2.4.3\">\n    <configVersion>2</configVersion>\n    <userRemoteConfigs>\n      <hudson.plugins.git.UserRemoteConfig>\n        <url>https://github.com/spring-projects/spring-petclinic.git</url>\n      </hudson.plugins.git.UserRemoteConfig>\n    </userRemoteConfigs>\n    <branches>\n      <hudson.plugins.git.BranchSpec>\n        <name>*/master</name>\n      </hudson.plugins.git.BranchSpec>\n    </branches>\n    <doGenerateSubmoduleConfigurations>false</doGenerateSubmoduleConfigurations>\n    <submoduleCfg class=\"list\"/>\n  </scm>\n  <canRoam>true</canRoam>\n  <disabled>false</disabled>\n  <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>\n  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>\n  <triggers/>\n  <concurrentBuild>false</concurrentBuild>\n  <builders>\n    <hudson.tasks.Maven>\n      <targets>clean package</targets>\n      <mavenName>3.3.9</mavenName>\n      <usePrivateRepository>false</usePrivateRepository>\n      <settings class=\"jenkins.mvn.DefaultSettingsProvider\"/>\n      <globalSettings class=\"jenkins.mvn.DefaultGlobalSettingsProvider\"/>\n    </hudson.tasks.Maven>\n  </builders>\n  <publishers>\n    <hudson.plugins.deploy.DeployPublisher plugin=\"deploy@1.10\">\n      <adapters>\n        <hudson.plugins.deploy.tomcat.Tomcat7xAdapter>\n          <userName>admin</userName>\n          <passwordScrambled>YWRtaW4=</passwordScrambled>\n          <url>http://localhost:8888</url>\n        </hudson.plugins.deploy.tomcat.Tomcat7xAdapter>\n      </adapters>\n      <contextPath>spring-petclinic</contextPath>\n      <war>target/*.war</war>\n      <onFailure>false</onFailure>\n    </hudson.plugins.deploy.DeployPublisher>\n  </publishers>\n  <buildWrappers/>\n</project>\n{% endgeshi %}\n\nWhen running this job, you should see in the end of the console output, something similar to this.\n\n{% geshi 'bash' %}\n[INFO] Building war: /tmp/1/jobs/deploy01/workspace/target/petclinic.war\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 20.590 s\n[INFO] Finished at: 2016-03-20T19:13:51+13:00\n[INFO] Final Memory: 36M/359M\n[INFO] ------------------------------------------------------------------------\nDeploying /tmp/1/jobs/deploy01/workspace/target/petclinic.war to container Tomcat 7.x Remote\n  [/tmp/1/jobs/deploy01/workspace/target/petclinic.war] is not deployed. Doing a fresh deployment.\n  Deploying [/tmp/1/jobs/deploy01/workspace/target/petclinic.war]\nFinished: SUCCESS\n{% endgeshi %}\n\nYou can chain several jobs, creating a pipeline with one job to build, one for functional tests, and\nanother job to deploy.\n\n### Pros\n\n* Since you are using Jenkins you can also chain other tools together, as well as other jobs, creating a build\npipeline (doable with the other two approaches, but just harder IMO)\n* Like in option #2, you can use parameters and customise the behaviour of the tools used\n* You can use Jenkins remote API or CLI to chain other tools or react to events in other systems\n(harder to achieve with the other approaches)\n\n### Cons\n\n* There is a learning curve for learning Jenkins, as well as any plug-in or other tools that you may be using\n* You have to maintain a new infrastructure with Jenkins\n* When new versions of containers are released, Jenkins developers, and plug-in developers may have to update and\nrelease an updated plug-in to be able to support these versions. You have to wait till that happens to use\nthe plug-in (or submit a patch/pull request)\n\n<h2><a name=\"final-thoughts\" style=\"color: #222222;\">Final thoughts</a></h2>\n\nWhenever I can, I try to avoid reinventing the wheel. The less code I write, and the more good quality\ncode that I reuse, the merrier for me. So approach #1 is my less favorite way of deploying WAR files to\nTomcat.\n\n**My preferred approach for deploying WAR files to Tomcat, is a mix of #2 and #3**.\n\nYou configure the deploy tasks in your build tool, be it Maven, Grunt, Ant, or etc. And configure a job\nin Jenkins to check out the code and deploy it, calling your build tool. \n\nUsing the previous examples, you would configure profiles in your pom.xml, and also combine parameters\nin Jenkins to define which profile to activate (as well as override parameters if necessary).\n\nThis way you give developers the power to choose how/where to deploy. In case they need to deploy to a\ndifferent environment, they can change the build scripts, commit, and wait for Jenkins to be ready to\ndeploy. Leaving the deployment environment configuration in Jenkins jobs would require developers to\nrequest changes in jobs, which would slow down the development pipeline.\n\nFurthermore, you can also overwrite values in the build tools, so you can still control it in the build\nserver too. And you are getting the best of both worlds, having Jenkins parameters, over 1000 plug-ins,\nand being able to create a build workflow/pipeline.\n\nBut remember, that is my opinion. I hope you can assimilate everything you have read here, and choose\nwhat will work best in your case.\n\nHappy hacking!\n", "o": 155, "f": null}]}}